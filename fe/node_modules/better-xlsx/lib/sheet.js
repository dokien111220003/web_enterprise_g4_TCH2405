"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sheet = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _row = require("./row");

var _col = require("./col");

var _style = require("./style");

var _lib = require("./lib");

var _xmlWorksheet = require("./xmlWorksheet");

/**
 * Sheet of the xlsx file.
 * ```js
 * import { File } from 'better-xlsx';
 * const file = new File();
 * const sheet = file.addSheet('Sheet-1');
 * const row = sheet.addRow();
 * const cell = row.addCell();
 * ```
 */
var Sheet = /*#__PURE__*/function () {
  function Sheet(_ref) {
    var name = _ref.name,
        file = _ref.file,
        selected = _ref.selected;
    (0, _classCallCheck2.default)(this, Sheet);
    (0, _defineProperty2.default)(this, "rows", []);
    (0, _defineProperty2.default)(this, "cols", []);
    (0, _defineProperty2.default)(this, "maxRow", 0);
    (0, _defineProperty2.default)(this, "maxCol", 0);
    (0, _defineProperty2.default)(this, "hidden", false);
    (0, _defineProperty2.default)(this, "sheetViews", []);
    (0, _defineProperty2.default)(this, "sheetFormat", {
      defaultColWidth: 0,
      defaultRowHeight: 0,
      outlineLevelCol: 0,
      outlineLevelRow: 0
    });
    this.name = name;
    this.file = file;
    this.selected = selected;
  }
  /**
   * Create a Row and add it into the Sheet.
   * @return {Row}
   */


  (0, _createClass2.default)(Sheet, [{
    key: "addRow",
    value: function addRow() {
      var row = new _row.Row({
        sheet: this
      });
      this.rows.push(row);

      if (this.rows.length > this.maxRow) {
        this.maxRow = this.rows.length;
      }

      return row;
    }
  }, {
    key: "maybeAddCol",
    value: function maybeAddCol(cellCount) {
      if (cellCount > this.maxCol) {
        var col = new _col.Col({
          min: cellCount,
          max: cellCount,
          hidden: false,
          collapsed: false
        });
        this.cols.push(col);
        this.maxCol = cellCount;
      }
    }
    /**
     * Get Col of the sheet with index and create cols when `index > maxCol`.
     * @param  {Number} idx Index of the Col [from 0].
     * @return {Col}
     */

  }, {
    key: "col",
    value: function col(idx) {
      this.maybeAddCol(idx + 1);
      return this.cols[idx];
    }
    /**
     * Get Row of the sheet with index and create rows when `index > maxRow`.
     * @param  {Number} idx Index of the Row [from 0].
     * @return {Row}
     */

  }, {
    key: "row",
    value: function row(idx) {
      for (var len = this.rows.length; len <= idx; len++) {
        this.addRow();
      }

      return this.rows[idx];
    }
    /**
     * Get Cell of the sheet with `(row, col)` and create cell when out of range.
     * @param  {Number} row
     * @param {Number} col
     * @return {Cell}
     */

  }, {
    key: "cell",
    value: function cell(row, col) {
      for (var len = this.rows.length; len <= row; len++) {
        this.addRow();
      }

      var r = this.rows[row];

      for (var _len = r.cells.length; _len <= col; _len++) {
        r.addCell();
      }

      return r.cells[col];
    }
    /**
     * Set columns width from `startcol` to `endcol`.
     * @param {Number} startcol
     * @param {Number} endcol
     * @param {Number} width
     */

  }, {
    key: "setColWidth",
    value: function setColWidth(startcol, endcol, width) {
      if (startcol > endcol) {
        throw new Error(`Could not set width for range ${startcol}-${endcol}: startcol must be less than endcol.`);
      }

      var col = new _col.Col({
        min: startcol + 1,
        max: endcol + 1,
        hidden: false,
        collapsed: false,
        width: width
      });
      this.cols.push(col);

      if (endcol + 1 > this.maxCol) {
        this.maxCol = endcol + 1;
      }
    }
  }, {
    key: "handleMerged",
    value: function handleMerged() {
      var _this = this;

      var merged = [];

      for (var r = 0; r < this.rows.length; r++) {
        var row = this.rows[r];

        for (var c = 0; c < row.cells.length; c++) {
          var cell = row.cells[c];

          if (cell.hMerge > 0 || cell.vMerge > 0) {
            merged.push({
              r,
              c,
              cell
            });
          }
        }
      }

      var _loop = function _loop() {
        var _merged$_i = _merged[_i],
            r = _merged$_i.r,
            c = _merged$_i.c,
            cell = _merged$_i.cell;
        var border = cell.style.border;
        cell.style.border = new _style.Border({});

        for (var rownum = 0; rownum <= cell.vMerge; rownum++) {
          var _loop2 = function _loop2(colnum) {
            var tmpcell = _this.cell(r + rownum, c + colnum);

            var arr = [];

            if (rownum === 0) {
              arr.push('top');
            }

            if (rownum === cell.vMerge) {
              arr.push('bottom');
            }

            if (colnum === 0) {
              arr.push('left');
            }

            if (colnum === cell.hMerge) {
              arr.push('right');
            }

            if (arr.length) {
              tmpcell.style.applyBorder = true;
              arr.forEach(function (k) {
                var ck = `${k}Color`;
                tmpcell.style.border[k] = border[k];
                tmpcell.style.border[ck] = border[ck];
              });
            }
          };

          for (var colnum = 0; colnum <= cell.hMerge; colnum++) {
            _loop2(colnum);
          }
        }
      };

      for (var _i = 0, _merged = merged; _i < _merged.length; _i++) {
        _loop();
      }
    }
  }, {
    key: "makeXSheet",
    value: function makeXSheet(refTable, styles) {
      var sheet = (0, _xmlWorksheet.makeXworksheet)();
      var xSheet = new _xmlWorksheet.XsheetData();
      var maxRow = 0;
      var maxCell = 0;
      var maxLevelCol;
      var maxLevelRow;
      this.handleMerged();

      for (var i = 0; i < this.sheetViews.length; i++) {
        var view = this.sheetViews[i];

        if (view && view.pane) {
          sheet.sheetViews.children[i].children.push(new _xmlWorksheet.Xpane({
            xSplit: view.pane.xSplit,
            ySplit: view.pane.ySplit,
            topLeftCell: view.pane.topLeftCell,
            activePane: view.pane.activePane,
            state: view.pane.state
          }));
        }
      }

      if (this.selected) {
        sheet.sheetViews.children[0].tabSelected = true;
      }

      if (this.sheetFormat.defaultRowHeight !== 0) {
        sheet.sheetFormatPr.defaultRowHeight = this.sheetFormat.defaultRowHeight;
      }

      if (this.sheetFormat.defaultColWidth !== 0) {
        sheet.sheetFormatPr.defaultColWidth = this.sheetFormat.defaultColWidth;
      }

      var fIdList = [];
      sheet.cols = new _xmlWorksheet.Xcols();

      for (var c = 0; c < this.cols.length; c++) {
        var col = this.cols[c];
        col.min = col.min || 1;
        col.max = col.max || 1;
        var xNumFmt = styles.newNumFmt(col.numFmt);
        var fId = (0, _style.handleStyle)(col.style, xNumFmt.numFmtId, styles);
        fIdList.push(fId);
        var customWidth = 0;

        if (col.width === 0) {
          col.width = 9.5;
        } else {
          customWidth = 1;
        }

        sheet.cols.children.push(new _xmlWorksheet.Xcol({
          min: col.min,
          max: col.max,
          hidden: col.hidden,
          width: col.width,
          customWidth: customWidth,
          collapsed: col.collapsed,
          outlineLevel: col.outlineLevel,
          style: fId
        }));

        if (col.outlineLevel > maxLevelCol) {
          maxLevelCol = col.outlineLevel;
        }
      }

      for (var r = 0; r < this.rows.length; r++) {
        var row = this.rows[r];
        if (r > maxRow) maxRow = r;
        var xRow = new _xmlWorksheet.Xrow({
          r: r + 1
        });

        if (row.isCustom) {
          xRow.customHeight = true;
          xRow.ht = row.height;
        }

        xRow.outlineLevel = row.outlineLevel;

        if (row.outlineLevel > maxLevelRow) {
          maxLevelRow = row.outlineLevel;
        }

        for (var _c = 0; _c < row.cells.length; _c++) {
          var _fId = fIdList[_c];
          var cell = row.cells[_c];

          var _xNumFmt = styles.newNumFmt(cell.numFmt);

          var style = cell.style;

          if (style !== null) {
            _fId = (0, _style.handleStyle)(style, _xNumFmt.numFmtId, styles);
          } else if (cell.numFmt && this.cols[_c].numFmt !== cell.numFmt) {
            _fId = (0, _style.handleNumFmtId)(_xNumFmt.NumFmtId, styles);
          }

          if (_c > maxCell) maxCell = _c;
          var xC = new _xmlWorksheet.Xc({
            r: `${(0, _lib.num2col)(_c)}${r + 1}`
          });

          switch (cell.cellType) {
            case 'TypeString':
              if (cell.value) {
                xC.v = refTable.addString(cell.value);
              }

              xC.t = 's';
              xC.s = _fId;
              break;

            case 'TypeBool':
              xC.v = cell.value;
              xC.t = 'b';
              xC.s = _fId;
              break;

            case 'TypeNumeric':
              xC.v = cell.value;
              xC.s = _fId;
              break;

            case 'TypeDate':
              xC.v = cell.value;
              xC.s = _fId;
              break;

            case 'TypeFormula':
              xC.v = cell.value;
              xC.f = new _xmlWorksheet.Xf({}, [cell.formula]);
              xC.s = _fId;
              break;

            case 'TypeError':
              xC.v = cell.value;
              xC.f = new _xmlWorksheet.Xf({}, [cell.formula]);
              xC.t = 'e';
              xC.s = _fId;
              break;

            case 'TypeGeneral':
              xC.v = cell.value;
              xC.s = _fId;
              break;
          }

          xRow.children.push(xC);

          if (cell.hMerge > 0 || cell.vMerge > 0) {
            // r == rownum, c == colnum
            var start = `${(0, _lib.num2col)(_c)}${r + 1}`;
            var endcol = _c + cell.hMerge;
            var endrow = r + cell.vMerge + 1;
            var end = `${(0, _lib.num2col)(endcol)}${endrow}`;
            var mc = new _xmlWorksheet.XmergeCell({
              ref: start + ':' + end
            });

            if (sheet.mergeCells === null) {
              sheet.mergeCells = new _xmlWorksheet.XmergeCells();
            }

            sheet.mergeCells.children.push(mc);
          }
        }

        xSheet.children.push(xRow);
      } // Update sheet format with the freshly determined max levels


      this.sheetFormat.outlineLevelCol = maxLevelCol;
      this.sheetFormat.outlineLevelRow = maxLevelRow; // .. and then also apply this to the xml worksheet

      sheet.sheetFormatPr.outlineLevelCol = this.sheetFormat.outlineLevelCol;
      sheet.sheetFormatPr.outlineLevelRow = this.sheetFormat.outlineLevelRow;

      if (sheet.mergeCells !== null) {
        sheet.mergeCells.count = sheet.mergeCells.children.length;
      }

      sheet.sheetData = xSheet;
      var dimension = new _xmlWorksheet.Xdimension({
        ref: `A1:${(0, _lib.num2col)(maxCell)}${maxRow + 1}`
      });

      if (dimension.ref === 'A1:A1') {
        dimension.ref = 'A1';
      }

      sheet.dimension = dimension;

      if (this.afterMake) {
        this.afterMake(sheet);
      }

      return sheet;
    }
  }]);
  return Sheet;
}();

exports.Sheet = Sheet;